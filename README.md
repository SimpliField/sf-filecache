[//]: # ( )
[//]: # (This file is automatically generated by a `metapak`)
[//]: # (module. Do not change it  except between the)
[//]: # (`content:start/end` flags, your changes would)
[//]: # (be overridden.)
[//]: # ( )
# sf-filecache
> Simple and smart FS based cache system.

[![Build status](https://secure.travis-ci.org/nfroidure/sf-filecache.svg)](https://travis-ci.org/nfroidure/sf-filecache)
[![Coverage Status](https://coveralls.io/repos/nfroidure/sf-filecache/badge.svg?branch=master)](https://coveralls.io/r/nfroidure/sf-filecache?branch=master)
[![NPM version](https://badge.fury.io/js/sf-filecache.svg)](https://npmjs.org/package/sf-filecache)
[![Dependency Status](https://david-dm.org/nfroidure/sf-filecache.svg)](https://david-dm.org/nfroidure/sf-filecache)
[![devDependency Status](https://david-dm.org/nfroidure/sf-filecache/dev-status.svg)](https://david-dm.org/nfroidure/sf-filecache#info=devDependencies)
[![Dependency Status](https://dependencyci.com/github/nfroidure/sf-filecache/badge)](https://dependencyci.com/github/nfroidure/sf-filecache)
[![Package Quality](http://npm.packagequality.com/shield/sf-filecache.svg)](http://packagequality.com/#?package=sf-filecache)
[![Code Climate](https://codeclimate.com/github/nfroidure/sf-filecache.svg)](https://codeclimate.com/github/nfroidure/sf-filecache)


[//]: # (::contents:start)

This simple cache exists for two purposes:

- having a streameable `fs` based cache system
- opening only one file descriptor for cache queries by keeping the TTL infos
  along with the cached contents.

It is suitable when the cached contents is too heavy to use an in-memory cache
like Redis. It is also a good alternative to
[`memory-kv-store`](https://github.com/nfroidure/memory-kv-store) when you want
to cache some data in your local developper environnement without using the
Docker's RAM :D.

## Usage

```js
import os from 'os';
import process from 'process';
import ms from 'ms';
import path from 'path';
import initFileCache from 'sf-filecache';

const fileCache = await initFileCache({
  FS_CACHE_DIR = path.join(os.tempdir(), `__nodeFileCache-${process.pid}`),
  FS_CACHE_TTL = ms('3h'),
  time = Date.now.bind(Date), // Optional, default to this
  log = console.log.bind(console), // Optional, default to this
});

var endOfLife = Date.now() + 36000;


// Buffer based
fileCache.set('plop', new Buffer('plop!'), endOfLife)
.then(() => fileCache.get('plop'))
.then(data => console.log(data.toString()));
// Prints: plop!

// Stream based:
fileCache.setStream('plop', fs.createReadStream('file'), endOfLife)
.then(() => fileCache.getStream('plop'))
.then(stream => stream.pipe(process.stdout));
// Prints: plop!

```

[//]: # (::contents:end)

# API
## Functions

<dl>
<dt><a href="#initFileCache">initFileCache(services)</a> ⇒ <code><a href="#FileCache">Promise.&lt;FileCache&gt;</a></code></dt>
<dd><p>Instantiate the file cache service</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#FileCache">FileCache</a> : <code>Object</code></dt>
<dd></dd>
</dl>

<a name="initFileCache"></a>

## initFileCache(services) ⇒ [<code>Promise.&lt;FileCache&gt;</code>](#FileCache)
Instantiate the file cache service

**Kind**: global function  
**Returns**: [<code>Promise.&lt;FileCache&gt;</code>](#FileCache) - A promise of the file cache service  

| Param | Type | Description |
| --- | --- | --- |
| services | <code>Object</code> | The services to inject |
| [services.log] | <code>function</code> | A logging function |
| [services.lock] | <code>function</code> | A lock service to avoid race conditions on the same key |
| services.FS_CACHE_TTL | <code>Number</code> | The store time to live in milliseconds |
| [services.FS_CACHE_DIR] | <code>String</code> | The store for values as a simple object, it is useful  to get a synchronous access to the store in tests  for example. |

**Example**  
```js
import initFileCache from 'sf-filecache';
import initLock from 'common-services/dist/lock';
import initDelay from 'common-services/dist/delay';

const delay = await initDelay({});
const lock = await initLock({ delay });
const fileCache = await initFileCache({
  FS_CACHE_DIR: '_cache/dir',
  lock,
});
```
<a name="FileCache"></a>

## FileCache : <code>Object</code>
**Kind**: global typedef  

* [FileCache](#FileCache) : <code>Object</code>
    * [.get(key)](#FileCache.get) ⇒ <code>Promise.&lt;Buffer&gt;</code>
    * [.getStream(key)](#FileCache.getStream) ⇒ <code>Promise.&lt;ReadableStream&gt;</code>
    * [.set(key, data, eol)](#FileCache.set) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.setStream(key, stream, eol)](#FileCache.setStream) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.setEOL(key, eol)](#FileCache.setEOL) ⇒ <code>Promise.&lt;void&gt;</code>

<a name="FileCache.get"></a>

### FileCache.get(key) ⇒ <code>Promise.&lt;Buffer&gt;</code>
Get cached data for the given key

**Kind**: static method of [<code>FileCache</code>](#FileCache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>String</code> | The key |

<a name="FileCache.getStream"></a>

### FileCache.getStream(key) ⇒ <code>Promise.&lt;ReadableStream&gt;</code>
Get cached data as a stream for the given key

**Kind**: static method of [<code>FileCache</code>](#FileCache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>String</code> | The key |

<a name="FileCache.set"></a>

### FileCache.set(key, data, eol) ⇒ <code>Promise.&lt;void&gt;</code>
Set cached data at the given key

**Kind**: static method of [<code>FileCache</code>](#FileCache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>String</code> | The key |
| data | <code>Buffer</code> | The data to store |
| eol | <code>Number</code> | The resource invalidity timestamp |

<a name="FileCache.setStream"></a>

### FileCache.setStream(key, stream, eol) ⇒ <code>Promise.&lt;void&gt;</code>
Set cached data via a stream at the given key

**Kind**: static method of [<code>FileCache</code>](#FileCache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>String</code> | The key |
| stream | <code>ReadableStream</code> | The data to store as a readable stream |
| eol | <code>Number</code> | The resource invalidity timestamp |

<a name="FileCache.setEOL"></a>

### FileCache.setEOL(key, eol) ⇒ <code>Promise.&lt;void&gt;</code>
Set end of life to the given key (may be use to either delete
 or increase a key lifetime).

**Kind**: static method of [<code>FileCache</code>](#FileCache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>String</code> | The key |
| eol | <code>Number</code> | The resource invalidity timestamp |


# Authors
- [Nicolas Froidure](http://insertafter.com/en/index.html)

# License
[MIT](https://github.com/nfroidure/sf-filecache/blob/master/LICENSE)
